/*
 * Copyright (c) Sean McBane 2018, under the terms of the MIT license.
 * See LICENSE.txt for details.
 */

#include "ThreadPool.hpp"

#include <cmath>
#include <cstdio>
#include <random>

// Estimates pi by generating random points in [0.0, 1.0]^2
// The ratio of points that are in a circle with radius 1 to the
// total number of points should go to pi / 4 as n goes to infinity.
double estimate_pi(unsigned long num_points, 
                   std::default_random_engine gen)
{
    unsigned long points_in_circle = 0;
    
    for (unsigned long i = 0; i < num_points; ++i) {
        double x = double(gen()) / gen.max();
        double y = double(gen()) / gen.max();
        if (sqrt(x*x + y*y) < 1.0)
            points_in_circle += 1;
    }
    
    return (4.0 * points_in_circle) / num_points;
}

int main()
{
    ThreadPool::ThreadPool thread_pool(4);
    
    // Get seeds for the random number generators from /dev/urandom
    typename std::default_random_engine::result_type seeds[100];
    auto urandom = fopen("/dev/urandom", "r");
    fread(seeds, sizeof(seeds[0]), 100, urandom);
    fclose(urandom);
    
    std::vector<std::future<double>> futures;
    
    // Compute pi with ten billion points generated by submitting 100 tasks
    // each computing pi independently with 100 million points.
    for (int i = 0; i < 100; ++i) {
        futures.push_back(
            thread_pool.submit(estimate_pi, 100000000UL, 
                               std::default_random_engine(seeds[i])));
    }
    
    double total = 0;
    for (int i = 0; i < 100; ++i) {
        std::cout << "Getting result from task " << i << "...\n";
        total += futures[i].get();
    }
    
    std::cout << "Computed result for pi: " << total / 100 << '\n';
    
    return 0;
}
    
